using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using static Zenvin.Services.SourceGenerator.GeneratorConstants;

namespace Zenvin.Services.SourceGenerator
{
	[Generator]
	public class InstallerGenerator : ISourceGenerator
	{
		void ISourceGenerator.Initialize (GeneratorInitializationContext context)
		{
			context.RegisterForSyntaxNotifications (() => new ServiceInstallerReceiver ());
		}

		void ISourceGenerator.Execute (GeneratorExecutionContext context)
		{
			if (!(context.SyntaxReceiver is ServiceInstallerReceiver rec))
				return;
			if (rec.DependentClasses.Count == 0)
				return;

			var sb = new StringBuilder ();
			var comp = context.Compilation;
			var members = new List<InjectMember> ();

			foreach (var tree in comp.SyntaxTrees)
			{
				var semModel = comp.GetSemanticModel (tree);

				foreach (var dep in rec.DependentClasses)
				{
					var classSymbol = semModel.GetDeclaredSymbol (dep) as ITypeSymbol;
					if (classSymbol == null)
						continue;
					if (classSymbol.IsStatic)
						continue;

					members.Clear ();
					var fields = classSymbol.GetMembers ()
						.OfType<IFieldSymbol>()
						.Select(field => new InjectMember(
							field, 
							field.GetAttributes()
								.FirstOrDefault (attr => attr.AttributeClass.ToDisplayString() == MemberAttributeName),
							field.Type)
						)
						.Where (field => field.Attribute != null);
					members.AddRange (fields);

					var properties = classSymbol.GetMembers ()
						.OfType<IPropertySymbol> ()
						.Where (prop => prop.SetMethod != null)
						.Select (prop => new InjectMember (
							prop,
							prop.GetAttributes ()
								.FirstOrDefault (attr => attr.AttributeClass.ToDisplayString () == MemberAttributeName),
							prop.Type))
						.Where(prop => prop.Attribute != null);
					members.AddRange (properties);

					if (members.Count == 0)
						continue;

					sb.Clear ();

					// Print Header
					sb.AppendLine ("<auto-generated></auto-generated>");
					
					// Open Namespace
					var ns = classSymbol.ContainingNamespace.IsGlobalNamespace ? null : classSymbol.ContainingNamespace.ToDisplayString();
					if (ns != null)
					{
						sb.Append ("namespace ");
						sb.AppendLine (ns);
						sb.AppendLine ("{");
					}

					// Open Class
					sb.Append ("\tpartial class ");
					sb.Append (classSymbol.Name);
					sb.AppendLine ("\t{");

					// Open Method
					// TODO: Make Name configurable
					// TODO: Allow deferred Initialization
					sb.Append ("\tprivate void ");
					sb.Append (InjectServicesMethodName);
					sb.AppendLine ("()");
					sb.AppendLine ("\t\t{");

					foreach (var member in members)
					{
						// Read Attribute Settings
						bool required = true;
						ITypeSymbol contractType = null;

						foreach (var arg in member.Attribute.NamedArguments)
						{
							if (TryGetNamedArgument (arg, AttrArgNameRequired, ref required))
								continue;
							if (TryGetNamedArgument (arg, AttrArgNameContractType, ref contractType))
								continue;
						}
						TryAssignPositionalArgument (member.Attribute.ConstructorArguments, 0, ref required);
						TryAssignPositionalArgument (member.Attribute.ConstructorArguments, 1, ref contractType);

						// Compile Arguments
						contractType = contractType ?? member.Type;
						var contractTypeName = contractType.ToDisplayString (SymbolDisplayFormat.FullyQualifiedFormat);
						var instanceTypeName = member.Type.ToDisplayString (SymbolDisplayFormat.FullyQualifiedFormat);
						var requiredText = required ? "true" : "false";

						// Write Assignment
						sb.Append ("\t\t\tthis.");
						sb.Append (member.Member.Name);
						sb.Append (" = global::");
						sb.Append (ServiceLocatorType);
						sb.Append ('.');
						sb.Append (GetMethodName);
						sb.Append ('<');
						sb.Append (contractTypeName);
						sb.Append (", ");
						sb.Append (instanceTypeName);
						sb.Append (">(");
						sb.Append (RequiredArgumentName);
						sb.Append (": ");
						sb.Append (requiredText);
						sb.Append (");");
						sb.AppendLine ();
					}

					// Close Method
					sb.AppendLine ("\t\t}");

					// Close Class
					sb.AppendLine ("\t}");

					// Close Namespace
					if (ns != null)
					{
						sb.AppendLine ("}");
					}


					context.AddSource ($"{classSymbol.ToDisplayString()}_ServiceInjector.g.cs", sb.ToString());
				}
			}
		}

		private static bool TryGetNamedArgument<T> (KeyValuePair<string, TypedConstant> arg, string name, ref T value)
		{
			if (arg.Key != name)
				return false;
			if (!(arg.Value.Value is T val))
				return false;

			value = val;
			return true;
		}

		private static void TryAssignPositionalArgument<T> (ImmutableArray<TypedConstant> constructorArguments, int position, ref T value)
		{
			if (position < 0)
				return;
			if (constructorArguments.Length <= position)
				return;
			if (!(constructorArguments[position].Value is T val))
				return;

			value = val;
		}
	}

	internal readonly struct InjectMember
	{
		public readonly ISymbol Member;
		public readonly AttributeData Attribute;
		public readonly ITypeSymbol Type;

		public InjectMember (ISymbol member, AttributeData attribute, ITypeSymbol type)
		{
			Member = member;
			Attribute = attribute;
			Type = type;
		}
	}
}
