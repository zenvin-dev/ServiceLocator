using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using static Zenvin.Services.SourceGenerator.GeneratorConstants;

namespace Zenvin.Services.SourceGenerator
{
	[Generator]
	public class InstallerGenerator : ISourceGenerator
	{
		void ISourceGenerator.Initialize (GeneratorInitializationContext context)
		{
			context.RegisterForSyntaxNotifications (() => new ServiceInstallerReceiver ());
		}

		void ISourceGenerator.Execute (GeneratorExecutionContext context)
		{
			if (!(context.SyntaxReceiver is ServiceInstallerReceiver rec))
				return;

			var comp = context.Compilation;
			var targets = new Dictionary<string, InjectClass> ();
			var members = new List<InjectMember> ();
			var callBase = new HashSet<string> ();

			CollectGenerationTargets (rec, comp, targets, members);
			CollectBaseClasses (targets, callBase);
			GenerateSources (ref context, targets, callBase);
		}


		private static void CollectGenerationTargets (
			ServiceInstallerReceiver rec,
			Compilation comp,
			Dictionary<string, InjectClass> targets,
			List<InjectMember> members)
		{
			foreach (var classDec in rec.CandidateClasses)
			{
				var classModel = comp.GetSemanticModel (classDec.SyntaxTree);

				if (!(classModel.GetDeclaredSymbol (classDec) is ITypeSymbol classSymbol))
					continue;

				var attrData = classSymbol
					.GetAttributes ()
					.FirstOrDefault (attr => attr.AttributeClass.ToDisplayString () == AnalysisConstants.ClassAttributeFullName);
				if (attrData == null)
					continue;

				if (!HasUnityBaseType (classSymbol))
					continue;

				members.Clear ();
				CollectGenerationMembers (classSymbol, members);
				if (members.Count == 0)
					continue;

				var target = new InjectClass (classSymbol, attrData, members.ToArray ());
				targets[classSymbol.ToDisplayString (SymbolDisplayFormat.FullyQualifiedFormat)] = target;
			}
		}

		private static void CollectGenerationMembers (
			ITypeSymbol type,
			List<InjectMember> members)
		{
			var typeMembers = type.GetMembers ();
			foreach (var member in typeMembers)
			{
				if (member.IsAbstract)
					continue;
				if (member.IsStatic)
					continue;
				if (member.IsExtern)
					continue;

				var attrData = member
					.GetAttributes ()
					.FirstOrDefault (attr => attr.AttributeClass.ToDisplayString () == AnalysisConstants.MemberAttributeFullName);
				if (attrData == null)
					continue;

				switch (member)
				{
					case IFieldSymbol field:
						InjectMemberFromSymbol (field, field.Type, attrData, field.IsReadOnly, members);
						break;
					case IPropertySymbol property:
						InjectMemberFromSymbol (property, property.Type, attrData, property.IsReadOnly, members);
						break;
				}
			}
		}

		private static void CollectBaseClasses (
			Dictionary<string, InjectClass> targets,
			HashSet<string> callBase)
		{
			foreach (var kvp in targets)
			{
				// If target base type is not an injection target
				if (!HasInjectionTargetBaseType (targets, kvp.Value.Class, callBase))
					continue;

				// Ensure that current target calls base implementation
				callBase.Add (kvp.Key);
			}
		}

		private static void InjectMemberFromSymbol (
			ISymbol member,
			ITypeSymbol type,
			AttributeData attrData,
			bool isReadOnly,
			List<InjectMember> members)
		{
			if (isReadOnly)
				return;

			bool required = true;
			ITypeSymbol contractType = null;

			foreach (var arg in attrData.NamedArguments)
			{
				if (TryGetNamedArgument (arg, AnalysisConstants.AttributeParameterNameRequired, ref required))
					continue;
				if (TryGetNamedArgument (arg, AnalysisConstants.AttributeParameterNameContractType, ref contractType))
					continue;
			}
			TryAssignPositionalArgument (attrData.ConstructorArguments, 0, ref required);
			TryAssignPositionalArgument (attrData.ConstructorArguments, 1, ref contractType);

			var inject = new InjectMember (member, type, contractType, required);
			members.Add (inject);
		}

		private static void GenerateSources (
			ref GeneratorExecutionContext context,
			Dictionary<string, InjectClass> targets,
			HashSet<string> callBase)
		{
			foreach (var target in targets)
			{
				if (target.Value.IsEmpty)
					continue;

				// sb.Clear ();
				GenerateSource (ref context, target.Value, callBase.Contains (target.Key), new StringBuilder ());
			}
		}

		private static void GenerateSource (ref GeneratorExecutionContext context, InjectClass target, bool callBase, StringBuilder sb)
		{
			// Write header
			sb.AppendLine ("/// <auto-generated>");
			sb.AppendLine ("/// This code was generated automatically by Zenvin.Services.SourceGenerator.InstallerGenerator.");
			sb.AppendLine ("/// </auto-generated>");
			sb.AppendLine ();

			// Open Namespace
			var classSymbol = target.Class;
			var ns = classSymbol.ContainingNamespace.IsGlobalNamespace ? null : classSymbol.ContainingNamespace.ToDisplayString ();
			var indent = '\0';
			if (ns != null)
			{
				indent = '\t';

				sb.Append ("namespace ");
				sb.AppendLine (ns);
				sb.AppendLine ("{");
			}


			// Open Class
			sb.Append (indent);
			sb.Append ("partial class ");
			sb.AppendLine (classSymbol.Name);
			sb.Append (indent);
			sb.AppendLine ("{");


			// Fill Method
			GenerateMethodSource (ref target, sb, indent, callBase);


			// Close Class
			sb.Append (indent);
			sb.AppendLine ("}");


			// Close Namespace
			if (ns != null)
			{
				sb.AppendLine ("}");
			}

			context.AddSource ($"{classSymbol.ToDisplayString ()}_ServiceInjector.g.cs", sb.ToString ());
		}

		private static void GenerateMethodSource (ref InjectClass target, StringBuilder sb, char indent, bool callBase)
		{
			// Open Method
			sb.Append (indent);
			sb.Append ("\tprotected ");
			if (callBase)
				sb.Append ("new ");
			sb.Append ("void ");
			sb.Append (InjectionConstants.MethodName);
			sb.Append ('(');

			sb.AppendFormat (
				"global::{0} {1} = {2}",

				InjectionConstants.ScopeParameterType,
				InjectionConstants.ScopeParameterName,
				InjectionConstants.ScopeParameterDefault
			);
			sb.Append (", ");
			sb.AppendFormat (
				"global::{0} {1} = {2}",

				InjectionConstants.FallbackParameterType,
				InjectionConstants.FallbackParameterName,
				InjectionConstants.FallbackParameterDefault
			);

			sb.AppendLine (")");
			sb.Append (indent);
			sb.AppendLine ("\t{");


			// Generate Call to Base Implementation
			if (callBase)
			{
				sb.Append (indent);
				sb.AppendFormat (
					"\t\tbase.{0}({1}, {2});",

					InjectionConstants.MethodName,
					InjectionConstants.ScopeParameterName,
					InjectionConstants.FallbackParameterName
				);
				sb.AppendLine ();
			}

			// Generate Calls to ServiceLocator
			foreach (var member in target.Members)
			{
				sb.Append (indent);
				sb.AppendFormat (
					"\t\t{0} = global::{1}.{2}<",

					member.Member.Name,
					IntegrationConstants.ServiceLocatorType,
					IntegrationConstants.GetMethodName
				);
				if (member.ContractType != null)
				{
					sb.Append (member.ContractType.ToDisplayString (SymbolDisplayFormat.FullyQualifiedFormat));
					sb.Append (", ");
				}
				sb.AppendFormat (
					"{0}>({1}: {2}, {3}: {4}, {5}: {6});",

					member.Type.ToDisplayString (SymbolDisplayFormat.FullyQualifiedFormat),
					IntegrationConstants.ScopeArgumentName,
					InjectionConstants.ScopeParameterName,
					IntegrationConstants.FallbackArgumentName,
					InjectionConstants.FallbackParameterName,
					IntegrationConstants.RequiredArgumentName,
					member.Required ? "true" : "false"
				);
				sb.AppendLine ();
			}


			// Close Method
			sb.Append (indent);
			sb.AppendLine ("\t}");
		}


		private static bool HasUnityBaseType (ITypeSymbol symbol)
		{
			if (symbol == null)
				return false;

			symbol = symbol.BaseType;
			while (symbol != null)
			{
				var name = symbol.ToDisplayString ();
				if (name == "UnityEngine.MonoBehaviour" || name == "UnityEngine.ScriptableObject")
					return true;

				symbol = symbol.BaseType;
			}

			return false;
		}

		private static bool HasInjectionTargetBaseType (Dictionary<string, InjectClass> targets, ITypeSymbol type, HashSet<string> callBase)
		{
			type = type?.BaseType;
			while (type != null)
			{
				var baseTypeKey = type.ToDisplayString (SymbolDisplayFormat.FullyQualifiedFormat);
				if (baseTypeKey != null && targets.ContainsKey (baseTypeKey))
					return true;

				type = type.BaseType;
			}
			return false;
		}

		private static bool TryGetNamedArgument<T> (KeyValuePair<string, TypedConstant> arg, string name, ref T value)
		{
			if (arg.Key != name)
				return false;
			if (!(arg.Value.Value is T val))
				return false;

			value = val;
			return true;
		}

		private static void TryAssignPositionalArgument<T> (ImmutableArray<TypedConstant> constructorArguments, int position, ref T value)
		{
			if (position < 0)
				return;
			if (constructorArguments.Length <= position)
				return;
			if (!(constructorArguments[position].Value is T val))
				return;

			value = val;
		}
	}
}
